# paypal_server_sdk
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module PaypalServerSdk
  # The purchase unit details. Used to capture required information for the
  # payment contract.
  class PurchaseUnit < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The API caller-provided external ID for the purchase unit. Required for
    # multiple purchase units when you must update the order through `PATCH`. If
    # you omit this value and the order contains only one purchase unit, PayPal
    # sets this value to `default`. <blockquote><strong>Note:</strong> If there
    # are multiple purchase units, <code>reference_id</code> is required for
    # each purchase unit.</blockquote>
    # @return [String]
    attr_accessor :reference_id

    # The total order amount with an optional breakdown that provides details,
    # such as the total item amount, total tax amount, shipping, handling,
    # insurance, and discounts, if any.<br/>If you specify `amount.breakdown`,
    # the amount equals `item_total` plus `tax_total` plus `shipping` plus
    # `handling` plus `insurance` minus `shipping_discount` minus
    # discount.<br/>The amount must be a positive number. For listed of
    # supported currencies and decimal precision, see the PayPal REST APIs <a
    # href="/docs/integration/direct/rest/currency-codes/">Currency Codes</a>.
    # @return [AmountWithBreakdown]
    attr_accessor :amount

    # The merchant who receives the funds and fulfills the order. The merchant
    # is also known as the payee.
    # @return [Payee]
    attr_accessor :payee

    # Any additional payment instructions to be consider during payment
    # processing. This processing instruction is applicable for Capturing an
    # order or Authorizing an Order.
    # @return [PaymentInstruction]
    attr_accessor :payment_instruction

    # The purchase description.
    # @return [String]
    attr_accessor :description

    # The API caller-provided external ID. Used to reconcile API
    # caller-initiated transactions with PayPal transactions. Appears in
    # transaction and settlement reports.
    # @return [String]
    attr_accessor :custom_id

    # The API caller-provided external invoice ID for this order.
    # @return [String]
    attr_accessor :invoice_id

    # The PayPal-generated ID for the purchase unit. This ID appears in both the
    # payer's transaction history and the emails that the payer receives. In
    # addition, this ID is available in transaction and settlement reports that
    # merchants and API callers can use to reconcile transactions. This ID is
    # only available when an order is saved by calling
    # <code>v2/checkout/orders/id/save</code>.
    # @return [String]
    attr_accessor :id

    # The payment descriptor on account transactions on the customer's credit
    # card statement, that PayPal sends to processors. The maximum length of the
    # soft descriptor information that you can pass in the API field is 22
    # characters, in the following format:<code>22 - len(PAYPAL * (8)) -
    # len(<var>Descriptor in Payment Receiving Preferences of Merchant
    # account</var> + 1)</code>The PAYPAL prefix uses 8 characters.<br/><br/>The
    # soft descriptor supports the following ASCII
    # characters:<ul><li>Alphanumeric
    # characters</li><li>Dashes</li><li>Asterisks</li><li>Periods
    # (.)</li><li>Spaces</li></ul>For Wallet payments marketplace
    # integrations:<ul><li>The merchant descriptor in the Payment Receiving
    # Preferences must be the marketplace name.</li><li>You can't use the
    # remaining space to show the customer service number.</li><li>The remaining
    # spaces can be a combination of seller name and country.</li></ul><br/>For
    # unbranded payments (Direct Card) marketplace integrations, use a
    # combination of the seller name and phone number.
    # @return [String]
    attr_accessor :soft_descriptor

    # An array of items that the customer purchases from the merchant.
    # @return [Array[Item]]
    attr_accessor :items

    # The order shipping details.
    # @return [ShippingWithTrackingDetails]
    attr_accessor :shipping

    # Supplementary data about a payment. This object passes information that
    # can be used to improve risk assessments and processing costs, for example,
    # by providing Level 2 and Level 3 payment data.
    # @return [SupplementaryData]
    attr_accessor :supplementary_data

    # The collection of payments, or transactions, for a purchase unit in an
    # order. For example, authorized payments, captured payments, and refunds.
    # @return [PaymentCollection]
    attr_accessor :payments

    # The error reason code and description that are the reason for the most
    # recent order decline.
    # @return [Array[Object]]
    attr_accessor :most_recent_errors

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['reference_id'] = 'reference_id'
      @_hash['amount'] = 'amount'
      @_hash['payee'] = 'payee'
      @_hash['payment_instruction'] = 'payment_instruction'
      @_hash['description'] = 'description'
      @_hash['custom_id'] = 'custom_id'
      @_hash['invoice_id'] = 'invoice_id'
      @_hash['id'] = 'id'
      @_hash['soft_descriptor'] = 'soft_descriptor'
      @_hash['items'] = 'items'
      @_hash['shipping'] = 'shipping'
      @_hash['supplementary_data'] = 'supplementary_data'
      @_hash['payments'] = 'payments'
      @_hash['most_recent_errors'] = 'most_recent_errors'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        reference_id
        amount
        payee
        payment_instruction
        description
        custom_id
        invoice_id
        id
        soft_descriptor
        items
        shipping
        supplementary_data
        payments
        most_recent_errors
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(reference_id: SKIP, amount: SKIP, payee: SKIP,
                   payment_instruction: SKIP, description: SKIP,
                   custom_id: SKIP, invoice_id: SKIP, id: SKIP,
                   soft_descriptor: SKIP, items: SKIP, shipping: SKIP,
                   supplementary_data: SKIP, payments: SKIP,
                   most_recent_errors: SKIP)
      @reference_id = reference_id unless reference_id == SKIP
      @amount = amount unless amount == SKIP
      @payee = payee unless payee == SKIP
      @payment_instruction = payment_instruction unless payment_instruction == SKIP
      @description = description unless description == SKIP
      @custom_id = custom_id unless custom_id == SKIP
      @invoice_id = invoice_id unless invoice_id == SKIP
      @id = id unless id == SKIP
      @soft_descriptor = soft_descriptor unless soft_descriptor == SKIP
      @items = items unless items == SKIP
      @shipping = shipping unless shipping == SKIP
      @supplementary_data = supplementary_data unless supplementary_data == SKIP
      @payments = payments unless payments == SKIP
      @most_recent_errors = most_recent_errors unless most_recent_errors == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      reference_id = hash.key?('reference_id') ? hash['reference_id'] : SKIP
      amount = AmountWithBreakdown.from_hash(hash['amount']) if hash['amount']
      payee = Payee.from_hash(hash['payee']) if hash['payee']
      payment_instruction = PaymentInstruction.from_hash(hash['payment_instruction']) if
        hash['payment_instruction']
      description = hash.key?('description') ? hash['description'] : SKIP
      custom_id = hash.key?('custom_id') ? hash['custom_id'] : SKIP
      invoice_id = hash.key?('invoice_id') ? hash['invoice_id'] : SKIP
      id = hash.key?('id') ? hash['id'] : SKIP
      soft_descriptor =
        hash.key?('soft_descriptor') ? hash['soft_descriptor'] : SKIP
      # Parameter is an array, so we need to iterate through it
      items = nil
      unless hash['items'].nil?
        items = []
        hash['items'].each do |structure|
          items << (Item.from_hash(structure) if structure)
        end
      end

      items = SKIP unless hash.key?('items')
      shipping = ShippingWithTrackingDetails.from_hash(hash['shipping']) if hash['shipping']
      supplementary_data = SupplementaryData.from_hash(hash['supplementary_data']) if
        hash['supplementary_data']
      payments = PaymentCollection.from_hash(hash['payments']) if hash['payments']
      most_recent_errors =
        hash.key?('most_recent_errors') ? hash['most_recent_errors'] : SKIP

      # Create object from extracted values.
      PurchaseUnit.new(reference_id: reference_id,
                       amount: amount,
                       payee: payee,
                       payment_instruction: payment_instruction,
                       description: description,
                       custom_id: custom_id,
                       invoice_id: invoice_id,
                       id: id,
                       soft_descriptor: soft_descriptor,
                       items: items,
                       shipping: shipping,
                       supplementary_data: supplementary_data,
                       payments: payments,
                       most_recent_errors: most_recent_errors)
    end
  end
end

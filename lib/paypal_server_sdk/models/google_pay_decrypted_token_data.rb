# paypal_server_sdk
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module PaypalServerSdk
  # Details shared by Google for the merchant to be shared with PayPal. This is
  # required to process the transaction using the Google Pay payment method.
  class GooglePayDecryptedTokenData < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # A unique ID that identifies the message in case it needs to be revoked or
    # located at a later time.
    # @return [String]
    attr_accessor :message_id

    # Date and time at which the message expires as UTC milliseconds since
    # epoch. Integrators should reject any message that's expired.
    # @return [String]
    attr_accessor :message_expiration

    # The type of the payment credential. Currently, only CARD is supported.
    # @return [GooglePayPaymentMethod]
    attr_accessor :payment_method

    # The payment card used to fund a Google Pay payment. Can be a credit or
    # debit card.
    # @return [GooglePayCard]
    attr_accessor :card

    # Authentication Method which is used for the card transaction.
    # @return [GooglePayAuthenticationMethod]
    attr_accessor :authentication_method

    # Base-64 cryptographic identifier used by card schemes to validate the
    # token verification result. This is a conditionally required field if
    # authentication_method is CRYPTOGRAM_3DS.
    # @return [String]
    attr_accessor :cryptogram

    # Electronic Commerce Indicator may not always be present. It is only
    # returned for tokens on the Visa card network. This value is passed through
    # in the payment authorization request.
    # @return [String]
    attr_accessor :eci_indicator

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['message_id'] = 'message_id'
      @_hash['message_expiration'] = 'message_expiration'
      @_hash['payment_method'] = 'payment_method'
      @_hash['card'] = 'card'
      @_hash['authentication_method'] = 'authentication_method'
      @_hash['cryptogram'] = 'cryptogram'
      @_hash['eci_indicator'] = 'eci_indicator'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        message_id
        message_expiration
        cryptogram
        eci_indicator
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(payment_method:, card:, authentication_method:,
                   message_id: SKIP, message_expiration: SKIP, cryptogram: SKIP,
                   eci_indicator: SKIP)
      @message_id = message_id unless message_id == SKIP
      @message_expiration = message_expiration unless message_expiration == SKIP
      @payment_method = payment_method
      @card = card
      @authentication_method = authentication_method
      @cryptogram = cryptogram unless cryptogram == SKIP
      @eci_indicator = eci_indicator unless eci_indicator == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      payment_method =
        hash.key?('payment_method') ? hash['payment_method'] : nil
      card = GooglePayCard.from_hash(hash['card']) if hash['card']
      authentication_method =
        hash.key?('authentication_method') ? hash['authentication_method'] : nil
      message_id = hash.key?('message_id') ? hash['message_id'] : SKIP
      message_expiration =
        hash.key?('message_expiration') ? hash['message_expiration'] : SKIP
      cryptogram = hash.key?('cryptogram') ? hash['cryptogram'] : SKIP
      eci_indicator = hash.key?('eci_indicator') ? hash['eci_indicator'] : SKIP

      # Create object from extracted values.
      GooglePayDecryptedTokenData.new(payment_method: payment_method,
                                      card: card,
                                      authentication_method: authentication_method,
                                      message_id: message_id,
                                      message_expiration: message_expiration,
                                      cryptogram: cryptogram,
                                      eci_indicator: eci_indicator)
    end
  end
end
